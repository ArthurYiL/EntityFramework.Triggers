<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# var events = new [] { "Inserting", "InsertFailed", "Inserted", "Deleting", "DeleteFailed", "Deleted", "Updating", "UpdateFailed", "Updated" }; #>
using System;
using System.Collections.Immutable;
using Microsoft.Extensions.DependencyInjection;
#if EF_CORE
using Microsoft.EntityFrameworkCore;
namespace EntityFrameworkCore.Triggers {
#else
using System.Data.Entity;
namespace EntityFramework.Triggers {
#endif
	internal interface ITriggers<in TEntity, in TDbContext>
	where TEntity : class
	where TDbContext : DbContext
	{
<#
foreach (var @event in events)
{
#>
		void Raise<#= @event #>(I<#= @event #>Entry<TEntity, TDbContext> entry);
<#
}
#>
	}

	public class Triggers<TEntity, TDbContext> : ITriggers<TEntity, TDbContext>
	where TEntity : class
	where TDbContext : DbContext
	{
		private readonly IServiceProvider serviceProvider;
		public Triggers(IServiceProvider serviceProvider) => this.serviceProvider = serviceProvider;
		private TService S<TService>() => serviceProvider.GetService<TService>();

		struct WrappedHandler<TEntry> : IEquatable<WrappedHandler<TEntry>> where TEntry : IEntry<TEntity, TDbContext>
		{
			private readonly Object source;
			private readonly Action<TEntry> wrapper;
			public WrappedHandler(Object source, Action<TEntry> wrapper) { this.source = source; this.wrapper = wrapper; }
			public Boolean Equals(WrappedHandler<TEntry> other) => ReferenceEquals(source, other.source);
			public void Invoke(TEntry entry) => wrapper.Invoke(entry);
		}

		private static void Add<TEntry>(ref ImmutableArray<WrappedHandler<TEntry>> array, Object source, Action<TEntry> wrapper) where TEntry : IEntry<TEntity, TDbContext>
		{
			ImmutableArray<WrappedHandler<TEntry>> initial, computed;
			do
			{
				initial = ImmutableInterlockedRead(ref array);
				computed = initial.Add(new WrappedHandler<TEntry>(source, wrapper));
			}
			while (initial != ImmutableInterlocked.InterlockedCompareExchange(ref array, computed, initial));
		}

		private static void Remove<TEntry>(ref ImmutableArray<WrappedHandler<TEntry>> array, Object source) where TEntry : IEntry<TEntity, TDbContext>
		{
			ImmutableArray<WrappedHandler<TEntry>> initial, computed;
			do
			{
				initial = ImmutableInterlockedRead(ref array);
				var index = initial.LastIndexOf(new WrappedHandler<TEntry>(source, null));
				if (index == -1)
					return;
				computed = initial.RemoveAt(index);
			}
			while (initial != ImmutableInterlocked.InterlockedCompareExchange(ref array, computed, initial));
		}

		private static ImmutableArray<WrappedHandler<TEntry>> ImmutableInterlockedRead<TEntry>(ref ImmutableArray<WrappedHandler<TEntry>> array) where TEntry : IEntry<TEntity, TDbContext> =>
			ImmutableInterlocked.InterlockedCompareExchange(ref array, ImmutableArray<WrappedHandler<TEntry>>.Empty, ImmutableArray<WrappedHandler<TEntry>>.Empty);

<#
foreach (var @event in events)
{
		var camelCase = Char.ToLower(@event[0]) + @event.Substring(1);
#>
		private ImmutableArray<WrappedHandler<I<#= @event #>Entry<TEntity, TDbContext>>> <#= camelCase #> = ImmutableArray<WrappedHandler<I<#= @event #>Entry<TEntity, TDbContext>>>.Empty;
		
		void ITriggers<TEntity, TDbContext>.Raise<#= @event #>(I<#= @event #>Entry<TEntity, TDbContext> entry)
		{
			var latestHandlers = ImmutableInterlockedRead(ref <#= camelCase #>);
			for (var i = 0; i < latestHandlers.Length; i++)
				latestHandlers[i].Invoke(entry);
		}
		
		public void <#= @event #>Add(Action<I<#= @event #>Entry<TEntity, TDbContext>> handler) =>
			Add(ref <#=camelCase#>, handler, handler);

<#
	for (var i = 1; i != 16; i++)
	{
		var suffixes = Enumerable.Range(0, i).Select(x => i == 1 ? "" : (x + 1).ToString());
		var types = suffixes.Select(x => "TService" + x);
		var typeArgs = String.Join(", ", types);
		var serviceResolveCalls = String.Join(", ", types.Select(x => $"S<{x}>()"));
		var invokeParams = String.Join(", ", suffixes.Select(x => "TService" + x + " arg" + x));
		var invokeArgs = String.Join(", ", suffixes.Select(x => "service" + x));
#>
		public void <#= @event #>Add<<#= typeArgs #>>(Action<I<#= @event #>Entry<TEntity, TDbContext>, <#= typeArgs #>> handler) =>
			Add(ref <#=camelCase#>, handler, entry => handler.Invoke(entry, <#=serviceResolveCalls#>));

		public void <#= @event #>Remove<<#= typeArgs #>>(Action<I<#= @event #>Entry<TEntity, TDbContext>, <#= typeArgs #>> handler) =>
			Remove(ref <#=camelCase#>, handler);

<#
	}
#>

<#
}
#>
	}
}